'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('../../../dist/base-9fa7951e.cjs.dev.js');
var client = require('../../../dist/client-d5a20a13.cjs.dev.js');
require('eventemitter3');
require('../../../dist/chains-b4a51a84.cjs.dev.js');
require('../../../dist/rpcs-9c4eb960.cjs.dev.js');
require('ethers');
require('zustand/vanilla');
require('zustand/middleware');
require('ethers/lib/utils');

var _provider = /*#__PURE__*/new WeakMap();

var _getReady = /*#__PURE__*/new WeakSet();

var _findProvider = /*#__PURE__*/new WeakSet();

class MetaMaskConnector extends client.InjectedConnector {
  constructor() {
    let {
      chains,
      options: options_
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const options = {
      name: 'MetaMask',
      shimDisconnect: true,
      shimChainChangedDisconnect: true,
      ...options_
    };
    super({
      chains,
      options
    });

    base._classPrivateMethodInitSpec(this, _findProvider);

    base._classPrivateMethodInitSpec(this, _getReady);

    base._defineProperty(this, "id", 'metaMask');

    base._defineProperty(this, "ready", typeof window != 'undefined' && !!base._classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));

    base._classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
  }

  async getProvider() {
    if (typeof window !== 'undefined') {
      // TODO: Fallback to `ethereum#initialized` event for async injection
      // https://github.com/MetaMask/detect-provider#synchronous-and-asynchronous-injection=
      base._classPrivateFieldSet(this, _provider, base._classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));
    }

    return base._classPrivateFieldGet(this, _provider);
  }

}

function _getReady2(ethereum) {
  const isMetaMask = !!(ethereum !== null && ethereum !== void 0 && ethereum.isMetaMask);
  if (!isMetaMask) return; // Brave tries to make itself look like MetaMask
  // Could also try RPC `web3_clientVersion` if following is unreliable

  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;
  if (ethereum.isTokenary) return;
  return ethereum;
}

function _findProvider2(ethereum) {
  if (ethereum !== null && ethereum !== void 0 && ethereum.providers) return ethereum.providers.find(base._classPrivateMethodGet(this, _getReady, _getReady2));
  return base._classPrivateMethodGet(this, _getReady, _getReady2).call(this, ethereum);
}

exports.MetaMaskConnector = MetaMaskConnector;
