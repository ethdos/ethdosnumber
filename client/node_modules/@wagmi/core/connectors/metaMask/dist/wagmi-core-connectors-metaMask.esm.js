import { _ as _classPrivateMethodInitSpec, f as _defineProperty, j as _classPrivateMethodGet, g as _classPrivateFieldInitSpec, i as _classPrivateFieldSet, h as _classPrivateFieldGet } from '../../../dist/base-4c248b82.esm.js';
import { I as InjectedConnector } from '../../../dist/client-e01209d5.esm.js';
import 'eventemitter3';
import '../../../dist/chains-42648bc5.esm.js';
import '../../../dist/rpcs-7cfbd91c.esm.js';
import 'ethers';
import 'zustand/vanilla';
import 'zustand/middleware';
import 'ethers/lib/utils';

var _provider = /*#__PURE__*/new WeakMap();

var _getReady = /*#__PURE__*/new WeakSet();

var _findProvider = /*#__PURE__*/new WeakSet();

class MetaMaskConnector extends InjectedConnector {
  constructor() {
    let {
      chains,
      options: options_
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const options = {
      name: 'MetaMask',
      shimDisconnect: true,
      shimChainChangedDisconnect: true,
      ...options_
    };
    super({
      chains,
      options
    });

    _classPrivateMethodInitSpec(this, _findProvider);

    _classPrivateMethodInitSpec(this, _getReady);

    _defineProperty(this, "id", 'metaMask');

    _defineProperty(this, "ready", typeof window != 'undefined' && !!_classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));

    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
  }

  async getProvider() {
    if (typeof window !== 'undefined') {
      // TODO: Fallback to `ethereum#initialized` event for async injection
      // https://github.com/MetaMask/detect-provider#synchronous-and-asynchronous-injection=
      _classPrivateFieldSet(this, _provider, _classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));
    }

    return _classPrivateFieldGet(this, _provider);
  }

}

function _getReady2(ethereum) {
  const isMetaMask = !!(ethereum !== null && ethereum !== void 0 && ethereum.isMetaMask);
  if (!isMetaMask) return; // Brave tries to make itself look like MetaMask
  // Could also try RPC `web3_clientVersion` if following is unreliable

  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;
  if (ethereum.isTokenary) return;
  return ethereum;
}

function _findProvider2(ethereum) {
  if (ethereum !== null && ethereum !== void 0 && ethereum.providers) return ethereum.providers.find(_classPrivateMethodGet(this, _getReady, _getReady2));
  return _classPrivateMethodGet(this, _getReady, _getReady2).call(this, ethereum);
}

export { MetaMaskConnector };
