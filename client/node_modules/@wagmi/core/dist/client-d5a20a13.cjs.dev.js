'use strict';

var base = require('./base-9fa7951e.cjs.dev.js');
var ethers = require('ethers');
var create = require('zustand/vanilla');
var middleware = require('zustand/middleware');
var utils = require('ethers/lib/utils');
var chains = require('./chains-b4a51a84.cjs.dev.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var create__default = /*#__PURE__*/_interopDefault(create);

function getInjectedName(ethereum) {
  var _ethereum$providers, _getName;

  if (!ethereum) return 'Injected';

  const getName = provider => {
    if (provider.isBraveWallet) return 'Brave Wallet';
    if (provider.isCoinbaseWallet) return 'Coinbase Wallet';
    if (provider.isFrame) return 'Frame';
    if (provider.isOpera) return 'Opera';
    if (provider.isTally) return 'Tally';
    if (provider.isTokenary) return 'Tokenary';
    if (provider.isTrust) return 'Trust Wallet';
    if (provider.isMetaMask) return 'MetaMask';
  }; // Some injected providers detect multiple other providers and create a list at `ethers.providers`


  if ((_ethereum$providers = ethereum.providers) !== null && _ethereum$providers !== void 0 && _ethereum$providers.length) {
    var _names$;

    // Deduplicate names using Set
    // Coinbase Wallet puts multiple providers in `ethereum.providers`
    const nameSet = new Set();
    let unknownCount = 1;

    for (const provider of ethereum.providers) {
      let name = getName(provider);

      if (!name) {
        name = "Unknown Wallet #".concat(unknownCount);
        unknownCount += 1;
      }

      nameSet.add(name);
    }

    const names = [...nameSet];
    if (names.length) return names;
    return (_names$ = names[0]) !== null && _names$ !== void 0 ? _names$ : 'Injected';
  }

  return (_getName = getName(ethereum)) !== null && _getName !== void 0 ? _getName : 'Injected';
}

const cache = new Set();
function warn(message, id) {
  if (!cache.has(id !== null && id !== void 0 ? id : message)) {
    console.warn(message);
    cache.add(message);
  }
}

const shimKey = 'injected.shimDisconnect';

var _provider = /*#__PURE__*/new WeakMap();

var _switchingChains = /*#__PURE__*/new WeakMap();

var _isUserRejectedRequestError = /*#__PURE__*/new WeakSet();

class InjectedConnector extends base.Connector {
  constructor() {
    let {
      chains,
      options = {
        shimDisconnect: true
      }
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super({
      chains,
      options
    });

    base._classPrivateMethodInitSpec(this, _isUserRejectedRequestError);

    base._defineProperty(this, "id", void 0);

    base._defineProperty(this, "name", void 0);

    base._defineProperty(this, "ready", typeof window != 'undefined' && !!window.ethereum);

    base._classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });

    base._classPrivateFieldInitSpec(this, _switchingChains, {
      writable: true,
      value: void 0
    });

    base._defineProperty(this, "onAccountsChanged", accounts => {
      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {
        account: utils.getAddress(accounts[0])
      });
    });

    base._defineProperty(this, "onChainChanged", chainId => {
      const id = base.normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit('change', {
        chain: {
          id,
          unsupported
        }
      });
    });

    base._defineProperty(this, "onDisconnect", () => {
      var _this$options, _this$options2, _getClient$storage;

      // We need this as MetaMask can emit the "disconnect" event
      // upon switching chains. This workaround ensures that the
      // user currently isn't in the process of switching chains.
      if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimChainChangedDisconnect && base._classPrivateFieldGet(this, _switchingChains)) {
        base._classPrivateFieldSet(this, _switchingChains, false);

        return;
      }

      this.emit('disconnect');
      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage = getClient().storage) === null || _getClient$storage === void 0 ? void 0 : _getClient$storage.removeItem(shimKey);
    });

    let name = 'Injected';

    if (typeof window !== 'undefined') {
      const overrideName = options.name;
      const detectedName = getInjectedName(window.ethereum);
      if (overrideName) name = typeof overrideName === 'function' ? overrideName(detectedName) : overrideName;else name = typeof detectedName === 'string' ? detectedName : detectedName[0];
    }

    this.id = 'injected';
    this.name = name;
  }

  async connect() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    try {
      var _this$options3, _getClient$storage2;

      const provider = await this.getProvider();
      if (!provider) throw new base.ConnectorNotFoundError();

      if (provider.on) {
        provider.on('accountsChanged', this.onAccountsChanged);
        provider.on('chainChanged', this.onChainChanged);
        provider.on('disconnect', this.onDisconnect);
      }

      this.emit('message', {
        type: 'connecting'
      });
      const account = await this.getAccount(); // Switch to chain if provided

      let id = await this.getChainId();
      let unsupported = this.isChainUnsupported(id);

      if (chainId && id !== chainId) {
        const chain = await this.switchChain(chainId);
        id = chain.id;
        unsupported = this.isChainUnsupported(id);
      }

      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.shimDisconnect) (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(shimKey, true);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      if (base._classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) throw new base.UserRejectedRequestError(error);
      if (error.code === -32002) throw new base.ResourceUnavailableError(error);
      throw error;
    }
  }

  async disconnect() {
    var _this$options4, _getClient$storage3;

    const provider = await this.getProvider();
    if (!(provider !== null && provider !== void 0 && provider.removeListener)) return;
    provider.removeListener('accountsChanged', this.onAccountsChanged);
    provider.removeListener('chainChanged', this.onChainChanged);
    provider.removeListener('disconnect', this.onDisconnect);
    if ((_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.shimDisconnect) (_getClient$storage3 = getClient().storage) === null || _getClient$storage3 === void 0 ? void 0 : _getClient$storage3.removeItem(shimKey);
  }

  async getAccount() {
    const provider = await this.getProvider();
    if (!provider) throw new base.ConnectorNotFoundError();
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    }); // return checksum address

    return utils.getAddress(accounts[0]);
  }

  async getChainId() {
    const provider = await this.getProvider();
    if (!provider) throw new base.ConnectorNotFoundError();
    return await provider.request({
      method: 'eth_chainId'
    }).then(base.normalizeChainId);
  }

  async getProvider() {
    if (typeof window !== 'undefined' && !!window.ethereum) base._classPrivateFieldSet(this, _provider, window.ethereum);
    return base._classPrivateFieldGet(this, _provider);
  }

  async getSigner() {
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new ethers.providers.Web3Provider(provider).getSigner(account);
  }

  async isAuthorized() {
    try {
      var _this$options5, _getClient$storage4;

      if ((_this$options5 = this.options) !== null && _this$options5 !== void 0 && _this$options5.shimDisconnect && !((_getClient$storage4 = getClient().storage) !== null && _getClient$storage4 !== void 0 && _getClient$storage4.getItem(shimKey))) return false;
      const provider = await this.getProvider();
      if (!provider) throw new base.ConnectorNotFoundError();
      const accounts = await provider.request({
        method: 'eth_accounts'
      });
      const account = accounts[0];
      return !!account;
    } catch {
      return false;
    }
  }

  async switchChain(chainId) {
    var _this$options6;

    if ((_this$options6 = this.options) !== null && _this$options6 !== void 0 && _this$options6.shimChainChangedDisconnect) base._classPrivateFieldSet(this, _switchingChains, true);
    const provider = await this.getProvider();
    if (!provider) throw new base.ConnectorNotFoundError();
    const id = utils.hexValue(chainId);

    try {
      var _chains$find;

      await provider.request({
        method: 'wallet_switchEthereumChain',
        params: [{
          chainId: id
        }]
      });
      const chains$1 = [...this.chains, ...chains.allChains];
      return (_chains$find = chains$1.find(x => x.id === chainId)) !== null && _chains$find !== void 0 ? _chains$find : {
        id: chainId,
        name: "Chain ".concat(id),
        network: "".concat(id),
        rpcUrls: {
          default: ''
        }
      };
    } catch (error) {
      const chain = this.chains.find(x => x.id === chainId);
      if (!chain) throw new base.ChainNotConfiguredError(); // Indicates chain is not added to provider

      if (error.code === 4902) {
        try {
          await provider.request({
            method: 'wallet_addEthereumChain',
            params: [{
              chainId: id,
              chainName: chain.name,
              nativeCurrency: chain.nativeCurrency,
              rpcUrls: [chain.rpcUrls.default],
              blockExplorerUrls: this.getBlockExplorerUrls(chain)
            }]
          });
          return chain;
        } catch (addError) {
          if (base._classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, addError)) throw new base.UserRejectedRequestError(error);
          throw new base.AddChainError();
        }
      }

      if (base._classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) throw new base.UserRejectedRequestError(error);
      throw new base.SwitchChainError(error);
    }
  }

  async watchAsset(_ref) {
    let {
      address,
      decimals = 18,
      image,
      symbol
    } = _ref;
    const provider = await this.getProvider();
    if (!provider) throw new base.ConnectorNotFoundError();
    return await provider.request({
      method: 'wallet_watchAsset',
      params: {
        type: 'ERC20',
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }

}

function _isUserRejectedRequestError2(error) {
  return error.code === 4001;
}

const noopStorage = {
  getItem: _key => '',
  setItem: (_key, _value) => null,
  removeItem: _key => null
};
function createStorage(_ref) {
  let {
    storage,
    key: prefix = 'wagmi'
  } = _ref;
  return { ...storage,
    getItem: function (key) {
      let defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      const value = storage.getItem("".concat(prefix, ".").concat(key));

      try {
        return value ? JSON.parse(value) : defaultState;
      } catch (error) {
        console.warn(error);
        return defaultState;
      }
    },
    setItem: (key, value) => {
      if (value === null) {
        storage.removeItem("".concat(prefix, ".").concat(key));
      } else {
        try {
          storage.setItem("".concat(prefix, ".").concat(key), JSON.stringify(value));
        } catch (err) {
          console.error(err);
        }
      }
    },
    removeItem: key => storage.removeItem("".concat(prefix, ".").concat(key))
  };
}

const storeKey = 'store';

var _isAutoConnecting = /*#__PURE__*/new WeakMap();

var _lastUsedConnector = /*#__PURE__*/new WeakMap();

var _addEffects = /*#__PURE__*/new WeakSet();

class Client {
  constructor() {
    let {
      autoConnect = false,
      connectors = [new InjectedConnector()],
      provider: _provider = config => {
        try {
          return ethers.getDefaultProvider(config.chainId);
        } catch {
          return ethers.getDefaultProvider();
        }
      },
      storage = createStorage({
        storage: typeof window !== 'undefined' ? window.localStorage : noopStorage
      }),
      webSocketProvider: _webSocketProvider
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    base._classPrivateMethodInitSpec(this, _addEffects);

    base._defineProperty(this, "config", void 0);

    base._defineProperty(this, "storage", void 0);

    base._defineProperty(this, "store", void 0);

    base._classPrivateFieldInitSpec(this, _isAutoConnecting, {
      writable: true,
      value: void 0
    });

    base._classPrivateFieldInitSpec(this, _lastUsedConnector, {
      writable: true,
      value: void 0
    });

    // Check status for autoConnect flag
    let status = 'disconnected';

    let _chainId;

    if (autoConnect) {
      try {
        var _JSON$parse, _JSON$parse$state, _data$chain;

        const rawState = storage.getItem(storeKey, '');
        const data = (_JSON$parse = JSON.parse(rawState || '{}')) === null || _JSON$parse === void 0 ? void 0 : (_JSON$parse$state = _JSON$parse.state) === null || _JSON$parse$state === void 0 ? void 0 : _JSON$parse$state.data; // If account exists in localStorage, set status to reconnecting

        status = data !== null && data !== void 0 && data.account ? 'reconnecting' : 'connecting';
        _chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id; // eslint-disable-next-line no-empty
      } catch (_error) {}
    } // Evaluate initial store values


    const connectors_ = typeof connectors === 'function' ? connectors({
      chainId: _chainId
    }) : connectors;
    const provider_ = typeof _provider === 'function' ? _provider({
      chainId: _chainId
    }) : _provider;
    const webSocketProvider_ = typeof _webSocketProvider === 'function' ? _webSocketProvider({
      chainId: _chainId
    }) : _webSocketProvider; // Create store

    this.store = create__default["default"](middleware.subscribeWithSelector(middleware.persist(() => ({
      connectors: connectors_,
      provider: provider_,
      status,
      webSocketProvider: webSocketProvider_
    }), {
      name: storeKey,
      getStorage: () => storage,
      partialize: state => {
        var _state$data, _state$data2;

        return { ...(autoConnect && {
            data: {
              account: state === null || state === void 0 ? void 0 : (_state$data = state.data) === null || _state$data === void 0 ? void 0 : _state$data.account,
              chain: state === null || state === void 0 ? void 0 : (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : _state$data2.chain
            }
          }),
          chains: state === null || state === void 0 ? void 0 : state.chains
        };
      },
      version: 1
    })));
    this.config = {
      autoConnect,
      connectors,
      provider: _provider,
      storage,
      webSocketProvider: _webSocketProvider
    };
    this.storage = storage;

    base._classPrivateFieldSet(this, _lastUsedConnector, storage === null || storage === void 0 ? void 0 : storage.getItem('wallet'));

    base._classPrivateMethodGet(this, _addEffects, _addEffects2).call(this);
  }

  get chains() {
    return this.store.getState().chains;
  }

  get connectors() {
    return this.store.getState().connectors;
  }

  get connector() {
    return this.store.getState().connector;
  }

  get data() {
    return this.store.getState().data;
  }

  get error() {
    return this.store.getState().error;
  }

  get lastUsedChainId() {
    var _this$data, _this$data$chain;

    return (_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$chain = _this$data.chain) === null || _this$data$chain === void 0 ? void 0 : _this$data$chain.id;
  }

  get provider() {
    return this.store.getState().provider;
  }

  get status() {
    return this.store.getState().status;
  }

  get subscribe() {
    return this.store.subscribe;
  }

  get webSocketProvider() {
    return this.store.getState().webSocketProvider;
  }

  setState(updater) {
    const newState = typeof updater === 'function' ? updater(this.store.getState()) : updater;
    this.store.setState(newState, true);
  }

  clearState() {
    this.setState(x => ({ ...x,
      chains: undefined,
      connector: undefined,
      data: undefined,
      error: undefined,
      status: 'disconnected'
    }));
  }

  async destroy() {
    var _this$connector$disco, _this$connector;

    if (this.connector) await ((_this$connector$disco = (_this$connector = this.connector).disconnect) === null || _this$connector$disco === void 0 ? void 0 : _this$connector$disco.call(_this$connector));

    base._classPrivateFieldSet(this, _isAutoConnecting, false);

    this.clearState();
    this.store.destroy();
  }

  async autoConnect() {
    if (base._classPrivateFieldGet(this, _isAutoConnecting)) return;

    base._classPrivateFieldSet(this, _isAutoConnecting, true);

    if (!this.connectors.length) return; // Try last used connector first

    const sorted = base._classPrivateFieldGet(this, _lastUsedConnector) ? [...this.connectors].sort(x => x.id === base._classPrivateFieldGet(this, _lastUsedConnector) ? -1 : 1) : this.connectors;
    let connected = false;

    for (const connector of sorted) {
      if (!connector.ready || !connector.isAuthorized) continue;
      const isAuthorized = await connector.isAuthorized();
      if (!isAuthorized) continue;
      const data = await connector.connect();
      this.setState(x => ({ ...x,
        connector,
        chains: connector === null || connector === void 0 ? void 0 : connector.chains,
        data,
        status: 'connected'
      }));
      connected = true;
      break;
    } // If connecting didn't succeed, set to disconnected


    if (!connected) this.setState(x => ({ ...x,
      data: undefined,
      status: 'disconnected'
    }));

    base._classPrivateFieldSet(this, _isAutoConnecting, false);

    return this.data;
  }

  setLastUsedConnector() {
    var _this$storage;

    let lastUsedConnector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (_this$storage = this.storage) === null || _this$storage === void 0 ? void 0 : _this$storage.setItem('wallet', lastUsedConnector);
  }

}

function _addEffects2() {
  const onChange = data => {
    this.setState(x => ({ ...x,
      data: { ...x.data,
        ...data
      }
    }));
  };

  const onDisconnect = () => {
    this.clearState();
  };

  const onError = error => {
    this.setState(x => ({ ...x,
      error
    }));
  };

  this.store.subscribe(_ref => {
    let {
      connector
    } = _ref;
    return connector;
  }, (connector, prevConnector) => {
    var _prevConnector$off, _prevConnector$off2, _prevConnector$off3, _connector$on, _connector$on2, _connector$on3;

    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off = prevConnector.off) === null || _prevConnector$off === void 0 ? void 0 : _prevConnector$off.call(prevConnector, 'change', onChange);
    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off2 = prevConnector.off) === null || _prevConnector$off2 === void 0 ? void 0 : _prevConnector$off2.call(prevConnector, 'disconnect', onDisconnect);
    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off3 = prevConnector.off) === null || _prevConnector$off3 === void 0 ? void 0 : _prevConnector$off3.call(prevConnector, 'error', onError);
    if (!connector) return;
    (_connector$on = connector.on) === null || _connector$on === void 0 ? void 0 : _connector$on.call(connector, 'change', onChange);
    (_connector$on2 = connector.on) === null || _connector$on2 === void 0 ? void 0 : _connector$on2.call(connector, 'disconnect', onDisconnect);
    (_connector$on3 = connector.on) === null || _connector$on3 === void 0 ? void 0 : _connector$on3.call(connector, 'error', onError);
  });
  const {
    provider,
    webSocketProvider
  } = this.config;
  const subscribeProvider = typeof provider === 'function';
  const subscribeWebSocketProvider = typeof webSocketProvider === 'function';
  if (subscribeProvider || subscribeWebSocketProvider) this.store.subscribe(_ref2 => {
    var _data$chain2;

    let {
      data
    } = _ref2;
    return data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.id;
  }, chainId => {
    this.setState(x => ({ ...x,
      provider: subscribeProvider ? provider({
        chainId
      }) : x.provider,
      webSocketProvider: subscribeWebSocketProvider ? webSocketProvider({
        chainId
      }) : x.webSocketProvider
    }));
  });
}

exports.client = void 0;
function createClient(config) {
  const client_ = new Client(config);
  exports.client = client_;
  return client_;
}
function getClient() {
  if (!exports.client) {
    warn('No client defined. Falling back to default client.');
    return new Client();
  }

  return exports.client;
}

exports.Client = Client;
exports.InjectedConnector = InjectedConnector;
exports.createClient = createClient;
exports.createStorage = createStorage;
exports.getClient = getClient;
exports.noopStorage = noopStorage;
