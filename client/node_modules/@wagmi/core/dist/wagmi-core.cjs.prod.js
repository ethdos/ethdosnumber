'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var client = require('./client-a774f14a.cjs.prod.js');
var base = require('./base-b7c3f31e.cjs.prod.js');
var ethers$1 = require('ethers/lib/ethers');
var utils = require('ethers/lib/utils');
var chains = require('./chains-7204b2dd.cjs.prod.js');
var ethers = require('ethers');
var rpcs = require('./rpcs-b3c52116.cjs.prod.js');
require('zustand/vanilla');
require('zustand/middleware');
require('eventemitter3');

// https://ethereum.org/en/developers/docs/standards/tokens/erc-20
const erc20ABI = ['event Approval(address indexed _owner, address indexed _spender, uint256 _value)', 'event Transfer(address indexed _from, address indexed _to, uint256 _value)', 'function allowance(address _owner, address _spender) public view returns (uint256 remaining)', 'function approve(address _spender, uint256 _value) public returns (bool success)', 'function balanceOf(address _owner) public view returns (uint256 balance)', 'function decimals() public view returns (uint8)', 'function name() public view returns (string)', 'function symbol() public view returns (string)', 'function totalSupply() public view returns (uint256)', 'function transfer(address _to, uint256 _value) public returns (bool success)', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)']; // https://ethereum.org/en/developers/docs/standards/tokens/erc-721

const erc721ABI = ['event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId)', 'event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)', 'event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)', 'function approve(address _approved, uint256 _tokenId) external payable', 'function balanceOf(address _owner) external view returns (uint256)', 'function getApproved(uint256 _tokenId) external view returns (address)', 'function isApprovedForAll(address _owner, address _operator) external view returns (bool)', 'function name() view returns (string memory)', 'function ownerOf(uint256 _tokenId) external view returns (address)', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable', 'function setApprovalForAll(address _operator, bool _approved) external', 'function symbol() view returns (string memory)', 'function tokenByIndex(uint256 _index) view returns (uint256)', 'function tokenOfOwnerByIndex(address _owner, uint256 _index) view returns (uint256 tokenId)', 'function tokenURI(uint256 _tokenId) view returns (string memory)', 'function totalSupply() view returns (uint256)', 'function transferFrom(address _from, address _to, uint256 _tokenId) external payable'];

// https://github.com/ethers-io/ethers.js/blob/master/packages/units/src.ts/index.ts#L10-L18
const units = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];

function configureChains(defaultChains, providers) {
  let {
    minQuorum = 1,
    targetQuorum = 1,
    stallTimeout
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (!defaultChains.length) throw new Error('must have at least one chain');
  if (targetQuorum < minQuorum) throw new Error('quorum cannot be lower than minQuorum');
  let chains = [];
  const providers_ = {};
  const webSocketProviders_ = {};

  for (const chain of defaultChains) {
    let configExists = false;

    for (const provider of providers) {
      const apiConfig = provider(chain); // If no API configuration was found (ie. no RPC URL) for
      // this provider, then we skip and check the next one.

      if (!apiConfig) continue;
      configExists = true;

      if (!chains.some(_ref => {
        let {
          id
        } = _ref;
        return id === chain.id;
      })) {
        chains = [...chains, apiConfig.chain];
      }

      providers_[chain.id] = [...(providers_[chain.id] || []), apiConfig.provider];

      if (apiConfig.webSocketProvider) {
        webSocketProviders_[chain.id] = [...(webSocketProviders_[chain.id] || []), apiConfig.webSocketProvider];
      }
    } // If no API configuration was found across the providers
    // then we throw an error to the consumer.


    if (!configExists) {
      throw new Error(["Could not find valid provider configuration for chain \"".concat(chain.name, "\".\n"), "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.", 'Read more: https://wagmi.sh/docs/providers/jsonRpc'].join('\n'));
    }
  }

  return {
    chains,
    provider: _ref2 => {
      var _defaultChains$, _chainProviders$;

      let {
        chainId
      } = _ref2;
      const activeChainId = chainId && chains.some(x => x.id === chainId) ? chainId : (_defaultChains$ = defaultChains[0]) === null || _defaultChains$ === void 0 ? void 0 : _defaultChains$.id;
      const chainProviders = providers_[activeChainId];
      if (!chainProviders) throw new Error("No providers configured for chain \"".concat(activeChainId, "\""));
      if (chainProviders.length === 1) return (_chainProviders$ = chainProviders[0]) === null || _chainProviders$ === void 0 ? void 0 : _chainProviders$.call(chainProviders);
      return fallbackProvider(targetQuorum, minQuorum, chainProviders, {
        stallTimeout
      });
    },
    webSocketProvider: _ref3 => {
      var _defaultChains$2, _chainWebSocketProvid, _chainWebSocketProvid2;

      let {
        chainId
      } = _ref3;
      const activeChainId = chainId && chains.some(x => x.id === chainId) ? chainId : (_defaultChains$2 = defaultChains[0]) === null || _defaultChains$2 === void 0 ? void 0 : _defaultChains$2.id;
      const chainWebSocketProviders = webSocketProviders_[activeChainId];
      if (!chainWebSocketProviders) return undefined;
      if (chainWebSocketProviders.length === 1) return (_chainWebSocketProvid = chainWebSocketProviders[0]) === null || _chainWebSocketProvid === void 0 ? void 0 : _chainWebSocketProvid.call(chainWebSocketProviders); // WebSockets do not work with `fallbackProvider`
      // Default to first available

      return (_chainWebSocketProvid2 = chainWebSocketProviders[0]) === null || _chainWebSocketProvid2 === void 0 ? void 0 : _chainWebSocketProvid2.call(chainWebSocketProviders);
    }
  };
}

function fallbackProvider(targetQuorum, minQuorum, providers_, _ref4) {
  let {
    stallTimeout
  } = _ref4;

  try {
    return new ethers.providers.FallbackProvider(providers_.map((chainProvider, index) => {
      var _provider$priority, _provider$stallTimeou;

      const provider = chainProvider();
      return {
        provider,
        priority: (_provider$priority = provider.priority) !== null && _provider$priority !== void 0 ? _provider$priority : index,
        stallTimeout: (_provider$stallTimeou = provider.stallTimeout) !== null && _provider$stallTimeou !== void 0 ? _provider$stallTimeou : stallTimeout,
        weight: provider.weight
      };
    }), targetQuorum);
  } catch (error) {
    var _error$message;

    if (error !== null && error !== void 0 && (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('quorum will always fail; larger than total weight')) {
      if (targetQuorum === minQuorum) throw error;
      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {
        stallTimeout
      });
    }

    throw error;
  }
}

async function connect(_ref) {
  let {
    chainId,
    connector
  } = _ref;
  const activeConnector = client.client.connector;
  if (connector.id === (activeConnector === null || activeConnector === void 0 ? void 0 : activeConnector.id)) throw new base.ConnectorAlreadyConnectedError();
  const data = await connector.connect({
    chainId
  });
  client.client.setLastUsedConnector(connector.id);
  client.client.setState(x => ({ ...x,
    connector,
    chains: connector === null || connector === void 0 ? void 0 : connector.chains,
    data
  }));
  client.client.storage.setItem('connected', true);
  return { ...data,
    connector
  };
}

async function disconnect() {
  const client$1 = client.getClient();
  if (client$1.connector) await client$1.connector.disconnect();
  client$1.clearState();
  client$1.storage.removeItem('connected');
}

function getProvider() {
  let {
    chainId
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const client$1 = client.getClient();
  if (chainId && typeof client$1.config.provider === 'function') return client$1.config.provider({
    chainId
  });
  return client$1.provider;
}

function getWebSocketProvider() {
  let {
    chainId
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const client$1 = client.getClient();
  if (chainId && typeof client$1.config.webSocketProvider === 'function') return client$1.config.webSocketProvider({
    chainId
  });
  return client$1.webSocketProvider;
}

function watchProvider(args, callback) {
  const client$1 = client.getClient();

  const handleChange = async () => callback(getProvider(args));

  const unsubscribe = client$1.subscribe(_ref => {
    let {
      provider
    } = _ref;
    return provider;
  }, handleChange);
  return unsubscribe;
}

function watchWebSocketProvider(args, callback) {
  const client$1 = client.getClient();

  const handleChange = async () => callback(getWebSocketProvider(args));

  const unsubscribe = client$1.subscribe(_ref => {
    let {
      webSocketProvider
    } = _ref;
    return webSocketProvider;
  }, handleChange);
  return unsubscribe;
}

async function fetchBalance(_ref) {
  var _client$connector$cha, _client$connector, _chain$nativeCurrency, _chain$nativeCurrency2, _chain$nativeCurrency3, _chain$nativeCurrency4;

  let {
    addressOrName,
    chainId,
    formatUnits: unit = 'ether',
    token
  } = _ref;
  const client$1 = client.getClient();
  const provider = getProvider({
    chainId
  });

  if (token) {
    const contract = new ethers$1.Contract(token, erc20ABI, provider);
    const [value, decimals, symbol] = await Promise.all([contract.balanceOf(addressOrName), contract.decimals(), contract.symbol()]);
    return {
      decimals,
      formatted: utils.formatUnits(value, unit),
      symbol,
      unit,
      value
    };
  }

  const chains$1 = [...((_client$connector$cha = (_client$connector = client$1.connector) === null || _client$connector === void 0 ? void 0 : _client$connector.chains) !== null && _client$connector$cha !== void 0 ? _client$connector$cha : []), ...chains.allChains];
  const value = await provider.getBalance(addressOrName);
  const chain = chains$1.find(x => x.id === provider.network.chainId);
  return {
    decimals: (_chain$nativeCurrency = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency2 = chain.nativeCurrency) === null || _chain$nativeCurrency2 === void 0 ? void 0 : _chain$nativeCurrency2.decimals) !== null && _chain$nativeCurrency !== void 0 ? _chain$nativeCurrency : 18,
    formatted: utils.formatUnits(value, unit),
    symbol: (_chain$nativeCurrency3 = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency4 = chain.nativeCurrency) === null || _chain$nativeCurrency4 === void 0 ? void 0 : _chain$nativeCurrency4.symbol) !== null && _chain$nativeCurrency3 !== void 0 ? _chain$nativeCurrency3 : 'ETH',
    unit,
    value
  };
}

async function fetchSigner() {
  var _client$connector, _client$connector$get;

  const client$1 = client.getClient();
  const signer = (await ((_client$connector = client$1.connector) === null || _client$connector === void 0 ? void 0 : (_client$connector$get = _client$connector.getSigner) === null || _client$connector$get === void 0 ? void 0 : _client$connector$get.call(_client$connector))) || null;
  return signer;
}

function getAccount() {
  const {
    data,
    connector
  } = client.getClient();
  return {
    address: data === null || data === void 0 ? void 0 : data.account,
    connector
  };
}

function getNetwork() {
  var _client$data, _client$data$chain, _client$chains, _find, _client$data2;

  const client$1 = client.getClient();
  const chainId = (_client$data = client$1.data) === null || _client$data === void 0 ? void 0 : (_client$data$chain = _client$data.chain) === null || _client$data$chain === void 0 ? void 0 : _client$data$chain.id;
  const activeChains = (_client$chains = client$1.chains) !== null && _client$chains !== void 0 ? _client$chains : [];
  const activeChain = (_find = [...activeChains, ...chains.allChains].find(x => x.id === chainId)) !== null && _find !== void 0 ? _find : {
    id: chainId,
    name: "Chain ".concat(chainId),
    network: "".concat(chainId),
    rpcUrls: {
      default: ''
    }
  };
  return {
    chain: chainId ? { ...activeChain,
      ...((_client$data2 = client$1.data) === null || _client$data2 === void 0 ? void 0 : _client$data2.chain),
      id: chainId
    } : undefined,
    chains: activeChains
  };
}

async function signMessage(args) {
  try {
    const signer = await fetchSigner();
    if (!signer) throw new base.ConnectorNotFoundError();
    return await signer.signMessage(args.message);
  } catch (error) {
    if (error.code === 4001) throw new base.UserRejectedRequestError(error);
    throw error;
  }
}

async function signTypedData(args) {
  try {
    const signer = await fetchSigner();
    if (!signer) throw new base.ConnectorNotFoundError(); // Method name may be changed in the future, see https://docs.ethers.io/v5/api/signer/#Signer-signTypedData

    return await signer._signTypedData(args.domain, args.types, args.value);
  } catch (error) {
    if (error.code === 4001) throw new base.UserRejectedRequestError(error);
    throw error;
  }
}

async function switchNetwork(_ref) {
  var _client$connector;

  let {
    chainId
  } = _ref;
  const client$1 = client.getClient();
  if (!((_client$connector = client$1.connector) !== null && _client$connector !== void 0 && _client$connector.switchChain)) throw new base.SwitchChainNotSupportedError();
  const chain = await client$1.connector.switchChain(chainId);
  return chain;
}

function watchAccount(callback) {
  const client$1 = client.getClient();

  const handleChange = () => callback(getAccount());

  const unsubscribe = client$1.subscribe(_ref => {
    let {
      data,
      connector
    } = _ref;
    return {
      account: data === null || data === void 0 ? void 0 : data.account,
      connector
    };
  }, handleChange, {
    equalityFn: (selected, previous) => selected.account === previous.account && selected.connector === previous.connector
  });
  return unsubscribe;
}

function watchNetwork(callback) {
  const client$1 = client.getClient();

  const handleChange = () => callback(getNetwork());

  const unsubscribe = client$1.subscribe(_ref => {
    var _data$chain;

    let {
      data,
      chains
    } = _ref;
    return {
      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,
      chains
    };
  }, handleChange, {
    equalityFn: (selected, previous) => selected.chainId === previous.chainId && selected.chains === previous.chains
  });
  return unsubscribe;
}

function watchSigner(callback) {
  const client$1 = client.getClient();

  const handleChange = async () => callback(await fetchSigner());

  const unsubscribe = client$1.subscribe(_ref => {
    var _data$chain;

    let {
      data,
      connector
    } = _ref;
    return {
      account: data === null || data === void 0 ? void 0 : data.account,
      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,
      connector
    };
  }, handleChange, {
    equalityFn: (selected, previous) => selected.account === previous.account && selected.chainId === previous.chainId && selected.connector === previous.connector
  });
  return unsubscribe;
}

function getContract(_ref) {
  let {
    addressOrName,
    contractInterface,
    signerOrProvider
  } = _ref;
  return new ethers.Contract(addressOrName, contractInterface, signerOrProvider);
}

async function readContract(contractConfig, functionName) {
  let {
    args,
    chainId,
    overrides
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const provider = getProvider({
    chainId
  });
  const contract = getContract({
    signerOrProvider: provider,
    ...contractConfig
  });
  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];
  const contractFunction = contract[functionName];
  if (!contractFunction) console.warn("\"".concat(functionName, "\" does not in interface for contract \"").concat(contractConfig.addressOrName, "\""));
  const response = await (contractFunction === null || contractFunction === void 0 ? void 0 : contractFunction(...params));
  return response;
}

function watchContractEvent(
/** Contract configuration */
contractArgs,
/** Event name to listen to */
eventName, callback) {
  let {
    chainId,
    once
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  let contract;

  const watchEvent = async () => {
    if (contract) {
      var _contract;

      (_contract = contract) === null || _contract === void 0 ? void 0 : _contract.off(eventName, callback);
    }

    contract = getContract({
      signerOrProvider: getWebSocketProvider({
        chainId
      }) || getProvider({
        chainId
      }),
      ...contractArgs
    });
    if (once) contract.once(eventName, callback);else contract.on(eventName, callback);
  };

  watchEvent();
  const client$1 = client.getClient();
  const unsubscribe = client$1.subscribe(_ref => {
    let {
      provider,
      webSocketProvider
    } = _ref;
    return {
      provider,
      webSocketProvider
    };
  }, watchEvent, {
    equalityFn: (selected, previous) => selected.provider === previous.provider && selected.webSocketProvider === previous.webSocketProvider
  });
  return () => {
    var _contract2;

    (_contract2 = contract) === null || _contract2 === void 0 ? void 0 : _contract2.off(eventName, callback);
    unsubscribe();
  };
}

async function fetchBlockNumber() {
  let {
    chainId
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const provider = getProvider({
    chainId
  });
  const blockNumber = await provider.getBlockNumber();
  return blockNumber;
}

function watchBlockNumber(args, callback) {
  var _client$webSocketProv;

  let previousProvider;

  const createListener = provider => {
    if (previousProvider) {
      var _previousProvider;

      (_previousProvider = previousProvider) === null || _previousProvider === void 0 ? void 0 : _previousProvider.off('block', callback);
    }

    provider.on('block', callback);
    previousProvider = provider;
  };

  const client$1 = client.getClient();
  const provider_ = (_client$webSocketProv = client$1.webSocketProvider) !== null && _client$webSocketProv !== void 0 ? _client$webSocketProv : client$1.provider;
  if (args.listen) createListener(provider_);
  const unsubscribe = client$1.subscribe(_ref => {
    let {
      provider,
      webSocketProvider
    } = _ref;
    return {
      provider,
      webSocketProvider
    };
  }, async _ref2 => {
    let {
      provider,
      webSocketProvider
    } = _ref2;
    const provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;

    if (args.listen && provider_) {
      createListener(provider_);
    }

    callback(await fetchBlockNumber());
  }, {
    equalityFn: (selected, previous) => selected.provider === previous.provider && selected.webSocketProvider === previous.webSocketProvider
  });
  return () => {
    unsubscribe();
    provider_ === null || provider_ === void 0 ? void 0 : provider_.off('block', callback);
  };
}

function watchReadContract(contractConfig, functionName) {
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let callback = arguments.length > 3 ? arguments[3] : undefined;
  const client$1 = client.getClient();

  const handleChange = async () => callback(await readContract(contractConfig, functionName, config));

  const unwatch = config.listenToBlock ? watchBlockNumber({
    listen: true
  }, handleChange) : undefined;
  const unsubscribe = client$1.subscribe(_ref => {
    let {
      provider
    } = _ref;
    return provider;
  }, handleChange);
  return () => {
    unsubscribe();
    unwatch === null || unwatch === void 0 ? void 0 : unwatch();
  };
}

async function writeContract(contractConfig, functionName) {
  let {
    args,
    overrides
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const client$1 = client.getClient();
  if (!client$1.connector) throw new base.ConnectorNotFoundError();
  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];

  try {
    const signer = await client$1.connector.getSigner();
    const contract = getContract(contractConfig);
    const contractWithSigner = contract.connect(signer);
    const contractFunction = contractWithSigner[functionName];
    if (!contractFunction) console.warn("\"".concat(functionName, "\" does not exist in interface for contract \"").concat(contractConfig.addressOrName, "\""));
    const response = await contractFunction(...params);
    return response;
  } catch (error) {
    if (error.code === 4001) throw new base.UserRejectedRequestError(error);
    throw error;
  }
}

async function fetchEnsAddress(_ref) {
  let {
    chainId,
    name
  } = _ref;
  const provider = getProvider({
    chainId
  });
  const address = await provider.resolveName(name);

  try {
    return address ? utils.getAddress(address) : null;
  } catch (_error) {
    return null;
  }
}

async function fetchEnsAvatar(_ref) {
  let {
    addressOrName,
    chainId
  } = _ref;
  const provider = getProvider({
    chainId
  }); // TODO: Update with more advanced logic
  // https://github.com/ensdomains/ens-avatar

  const avatar = await provider.getAvatar(addressOrName);
  return avatar;
}

async function fetchEnsName(_ref) {
  let {
    address,
    chainId
  } = _ref;
  const provider = getProvider({
    chainId
  });
  return await provider.lookupAddress(address);
}

async function fetchEnsResolver(_ref) {
  let {
    chainId,
    name
  } = _ref;
  const provider = getProvider({
    chainId
  });
  const resolver = await provider.getResolver(name);
  return resolver;
}

async function fetchFeeData() {
  let {
    chainId,
    formatUnits: units = 'wei'
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const provider = getProvider({
    chainId
  });
  const feeData = await provider.getFeeData();
  const formatted = {
    gasPrice: feeData.gasPrice ? utils.formatUnits(feeData.gasPrice, units) : null,
    maxFeePerGas: feeData.maxFeePerGas ? utils.formatUnits(feeData.maxFeePerGas, units) : null,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? utils.formatUnits(feeData.maxPriorityFeePerGas, units) : null
  };
  return { ...feeData,
    formatted
  };
}

async function fetchToken(_ref) {
  let {
    address,
    chainId,
    formatUnits: units = 'ether'
  } = _ref;
  const provider = getProvider({
    chainId
  });
  const contract = new ethers$1.Contract(address, erc20ABI, provider);
  const [symbol, decimals, totalSupply] = await Promise.all([contract.symbol(), contract.decimals(), contract.totalSupply()]);
  const token = {
    address,
    decimals,
    symbol,
    totalSupply: {
      formatted: utils.formatUnits(totalSupply, units),
      value: totalSupply
    }
  };
  return token;
}

async function sendTransaction(args) {
  try {
    const signer = await fetchSigner();
    if (!signer) throw new base.ConnectorNotFoundError();
    const transaction = await signer.sendTransaction(args.request);
    return transaction;
  } catch (error) {
    if (error.code === 4001) throw new base.UserRejectedRequestError(error);
    throw error;
  }
}

async function waitForTransaction(_ref) {
  let {
    chainId,
    confirmations,
    hash,
    timeout,
    wait: wait_
  } = _ref;
  let promise;

  if (hash) {
    const provider = getProvider({
      chainId
    });
    promise = provider.waitForTransaction(hash, confirmations, timeout);
  } else if (wait_) promise = wait_(confirmations);else throw new Error('hash or wait is required');

  return await promise;
}

exports.Client = client.Client;
exports.InjectedConnector = client.InjectedConnector;
exports.createClient = client.createClient;
exports.createStorage = client.createStorage;
exports.noopStorage = client.noopStorage;
exports.AddChainError = base.AddChainError;
exports.ChainNotConfiguredError = base.ChainNotConfiguredError;
exports.Connector = base.Connector;
exports.ConnectorAlreadyConnectedError = base.ConnectorAlreadyConnectedError;
exports.ConnectorNotFoundError = base.ConnectorNotFoundError;
exports.ProviderRpcError = base.ProviderRpcError;
exports.ResourceUnavailableError = base.ResourceUnavailableError;
exports.RpcError = base.RpcError;
exports.SwitchChainError = base.SwitchChainError;
exports.SwitchChainNotSupportedError = base.SwitchChainNotSupportedError;
exports.UserRejectedRequestError = base.UserRejectedRequestError;
exports.normalizeChainId = base.normalizeChainId;
exports.allChains = chains.allChains;
exports.chain = chains.chain;
exports.chainId = chains.chainId;
exports.defaultChains = chains.defaultChains;
exports.defaultL2Chains = chains.defaultL2Chains;
exports.etherscanBlockExplorers = chains.etherscanBlockExplorers;
exports.alchemyRpcUrls = rpcs.alchemyRpcUrls;
exports.infuraRpcUrls = rpcs.infuraRpcUrls;
exports.configureChains = configureChains;
exports.connect = connect;
exports.disconnect = disconnect;
exports.erc20ABI = erc20ABI;
exports.erc721ABI = erc721ABI;
exports.fetchBalance = fetchBalance;
exports.fetchBlockNumber = fetchBlockNumber;
exports.fetchEnsAddress = fetchEnsAddress;
exports.fetchEnsAvatar = fetchEnsAvatar;
exports.fetchEnsName = fetchEnsName;
exports.fetchEnsResolver = fetchEnsResolver;
exports.fetchFeeData = fetchFeeData;
exports.fetchSigner = fetchSigner;
exports.fetchToken = fetchToken;
exports.getAccount = getAccount;
exports.getContract = getContract;
exports.getNetwork = getNetwork;
exports.getProvider = getProvider;
exports.getWebSocketProvider = getWebSocketProvider;
exports.readContract = readContract;
exports.sendTransaction = sendTransaction;
exports.signMessage = signMessage;
exports.signTypedData = signTypedData;
exports.switchNetwork = switchNetwork;
exports.units = units;
exports.waitForTransaction = waitForTransaction;
exports.watchAccount = watchAccount;
exports.watchBlockNumber = watchBlockNumber;
exports.watchContractEvent = watchContractEvent;
exports.watchNetwork = watchNetwork;
exports.watchProvider = watchProvider;
exports.watchReadContract = watchReadContract;
exports.watchSigner = watchSigner;
exports.watchWebSocketProvider = watchWebSocketProvider;
exports.writeContract = writeContract;
