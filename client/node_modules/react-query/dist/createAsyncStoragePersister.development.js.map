{"version":3,"file":"createAsyncStoragePersister.development.js","sources":["../src/createAsyncStoragePersister/asyncThrottle.ts","../src/core/utils.ts","../src/createAsyncStoragePersister/index.ts"],"sourcesContent":["export interface AsyncThrottleOptions {\n  interval?: number\n  onError?: (error: unknown) => void\n}\n\nconst noop = () => {\n  /* do nothing */\n}\n\nexport function asyncThrottle<Args extends readonly unknown[]>(\n  func: (...args: Args) => Promise<void>,\n  { interval = 1000, onError = noop }: AsyncThrottleOptions = {}\n) {\n  if (typeof func !== 'function') throw new Error('argument is not function.')\n\n  let running = false\n  let lastTime = 0\n  let timeout: ReturnType<typeof setTimeout>\n  let currentArgs: Args | null = null\n\n  const execFunc = async () => {\n    if (currentArgs) {\n      const args = currentArgs\n      currentArgs = null\n      try {\n        running = true\n        await func(...args)\n      } catch (error) {\n        onError(error)\n      } finally {\n        lastTime = Date.now() // this line must after 'func' executed to avoid two 'func' running in concurrent.\n        running = false\n      }\n    }\n  }\n\n  const delayFunc = async () => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => {\n      if (running) {\n        delayFunc() // Will come here when 'func' execution time is greater than the interval.\n      } else {\n        execFunc()\n      }\n    }, interval)\n  }\n\n  return (...args: Args) => {\n    currentArgs = args\n\n    const tooSoon = Date.now() - lastTime < interval\n    if (running || tooSoon) {\n      delayFunc()\n    } else {\n      execFunc()\n    }\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter(x => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, queryKey: arg1 }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, mutationKey: arg1 }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","import { PersistedClient, Persister, Promisable } from '../persistQueryClient'\nimport { asyncThrottle } from './asyncThrottle'\nimport { noop } from '../core/utils'\n\ninterface AsyncStorage {\n  getItem: (key: string) => Promise<string | null>\n  setItem: (key: string, value: string) => Promise<void>\n  removeItem: (key: string) => Promise<void>\n}\n\nexport type AsyncPersistRetryer = (props: {\n  persistedClient: PersistedClient\n  error: Error\n  errorCount: number\n}) => Promisable<PersistedClient | undefined>\n\ninterface CreateAsyncStoragePersisterOptions {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`.\n   */\n  storage: AsyncStorage | undefined\n  /** The key to use when storing the cache */\n  key?: string\n  /** To avoid spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (client: PersistedClient) => string\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: string) => PersistedClient\n\n  retry?: AsyncPersistRetryer\n}\n\nexport const createAsyncStoragePersister = ({\n  storage,\n  key = `REACT_QUERY_OFFLINE_CACHE`,\n  throttleTime = 1000,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n  retry,\n}: CreateAsyncStoragePersisterOptions): Persister => {\n  if (typeof storage !== 'undefined') {\n    const trySave = async (\n      persistedClient: PersistedClient\n    ): Promise<Error | undefined> => {\n      try {\n        await storage.setItem(key, serialize(persistedClient))\n      } catch (error) {\n        return error as Error\n      }\n    }\n\n    return {\n      persistClient: asyncThrottle(\n        async persistedClient => {\n          let client: PersistedClient | undefined = persistedClient\n          let error = await trySave(client)\n          let errorCount = 0\n          while (error && client) {\n            errorCount++\n            client = await retry?.({\n              persistedClient: client,\n              error,\n              errorCount,\n            })\n\n            if (client) {\n              error = await trySave(client)\n            }\n          }\n        },\n        { interval: throttleTime }\n      ),\n      restoreClient: async () => {\n        const cacheString = await storage.getItem(key)\n\n        if (!cacheString) {\n          return\n        }\n\n        return deserialize(cacheString) as PersistedClient\n      },\n      removeClient: () => storage.removeItem(key),\n    }\n  }\n\n  return {\n    persistClient: noop,\n    restoreClient: noop,\n    removeClient: noop,\n  }\n}\n"],"names":["noop","asyncThrottle","func","interval","onError","Error","running","lastTime","timeout","currentArgs","execFunc","args","error","Date","now","delayFunc","clearTimeout","setTimeout","tooSoon","undefined","createAsyncStoragePersister","storage","key","throttleTime","serialize","JSON","stringify","deserialize","parse","retry","trySave","persistedClient","setItem","persistClient","client","errorCount","restoreClient","cacheString","getItem","removeClient","removeItem"],"mappings":"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"}