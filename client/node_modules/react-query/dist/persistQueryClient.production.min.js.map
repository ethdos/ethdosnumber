{"version":3,"file":"persistQueryClient.production.min.js","sources":["../src/core/hydration.ts","../src/persistQueryClient/persist.ts","../src/reactjs/QueryClientProvider.tsx","../src/reactjs/isRestoring.tsx","../src/persistQueryClient/PersistQueryClientProvider.tsx","../src/persistQueryClient/retryStrategies.ts"],"sourcesContent":["import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {}\n): DehydratedState {\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach(mutation => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach(query => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state\n    )\n  })\n\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state\n    )\n  })\n}\n","import {\n  QueryClient,\n  dehydrate,\n  DehydratedState,\n  DehydrateOptions,\n  HydrateOptions,\n  hydrate,\n} from '../core'\n\nexport type Promisable<T> = T | PromiseLike<T>\n\nexport interface Persister {\n  persistClient(persistClient: PersistedClient): Promisable<void>\n  restoreClient(): Promisable<PersistedClient | undefined>\n  removeClient(): Promisable<void>\n}\n\nexport interface PersistedClient {\n  timestamp: number\n  buster: string\n  clientState: DehydratedState\n}\n\nexport interface PersistQueryClienRootOptions {\n  /** The QueryClient to persist */\n  queryClient: QueryClient\n  /** The Persister interface for storing and restoring the cache\n   * to/from a persisted location */\n  persister: Persister\n  /** A unique string that can be used to forcefully\n   * invalidate existing caches if they do not share the same buster string */\n  buster?: string\n}\n\nexport interface PersistedQueryClientRestoreOptions\n  extends PersistQueryClienRootOptions {\n  /** The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded */\n  maxAge?: number\n  /** The options passed to the hydrate function */\n  hydrateOptions?: HydrateOptions\n}\n\nexport interface PersistedQueryClientSaveOptions\n  extends PersistQueryClienRootOptions {\n  /** The options passed to the dehydrate function */\n  dehydrateOptions?: DehydrateOptions\n}\n\nexport interface PersistQueryClientOptions\n  extends PersistedQueryClientRestoreOptions,\n    PersistedQueryClientSaveOptions,\n    PersistQueryClienRootOptions {}\n\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\nexport async function persistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24,\n  buster = '',\n  hydrateOptions,\n}: PersistedQueryClientRestoreOptions) {\n  try {\n    const persistedClient = await persister.restoreClient()\n\n    if (persistedClient) {\n      if (persistedClient.timestamp) {\n        const expired = Date.now() - persistedClient.timestamp > maxAge\n        const busted = persistedClient.buster !== buster\n        if (expired || busted) {\n          persister.removeClient()\n        } else {\n          hydrate(queryClient, persistedClient.clientState, hydrateOptions)\n        }\n      } else {\n        persister.removeClient()\n      }\n    }\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      queryClient.getLogger().error(err)\n      queryClient\n        .getLogger()\n        .warn(\n          'Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.'\n        )\n    }\n    persister.removeClient()\n  }\n}\n\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\nexport async function persistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions,\n}: PersistedQueryClientSaveOptions) {\n  const persistClient: PersistedClient = {\n    buster,\n    timestamp: Date.now(),\n    clientState: dehydrate(queryClient, dehydrateOptions),\n  }\n\n  await persister.persistClient(persistClient)\n}\n\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\nexport function persistQueryClientSubscribe(\n  props: PersistedQueryClientSaveOptions\n) {\n  const unsubscribeQueryCache = props.queryClient\n    .getQueryCache()\n    .subscribe(() => {\n      persistQueryClientSave(props)\n    })\n\n  const unusbscribeMutationCache = props.queryClient\n    .getMutationCache()\n    .subscribe(() => {\n      persistQueryClientSave(props)\n    })\n\n  return () => {\n    unsubscribeQueryCache()\n    unusbscribeMutationCache()\n  }\n}\n\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\nexport function persistQueryClient(\n  props: PersistQueryClientOptions\n): [() => void, Promise<void>] {\n  let hasUnsubscribed = false\n  let persistQueryClientUnsubscribe: (() => void) | undefined\n  const unsubscribe = () => {\n    hasUnsubscribed = true\n    persistQueryClientUnsubscribe?.()\n  }\n\n  // Attempt restore\n  const restorePromise = persistQueryClientRestore(props).then(() => {\n    if (!hasUnsubscribed) {\n      // Subscribe to changes in the query cache to trigger the save\n      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props)\n    }\n  })\n\n  return [unsubscribe, restorePromise]\n}\n","import React from 'react'\n\nimport { QueryClient } from '../core'\nimport { ContextOptions } from '../reactjs/types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext))\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import React from 'react'\n\nimport { persistQueryClient, PersistQueryClientOptions } from './persist'\nimport { QueryClientProvider, QueryClientProviderProps } from '../reactjs'\nimport { IsRestoringProvider } from '../reactjs/isRestoring'\n\nexport type PersistQueryClientProviderProps = QueryClientProviderProps & {\n  persistOptions: Omit<PersistQueryClientOptions, 'queryClient'>\n  onSuccess?: () => void\n}\n\nexport const PersistQueryClientProvider = ({\n  client,\n  children,\n  persistOptions,\n  onSuccess,\n  ...props\n}: PersistQueryClientProviderProps): JSX.Element => {\n  const [isRestoring, setIsRestoring] = React.useState(true)\n  const refs = React.useRef({ persistOptions, onSuccess })\n\n  React.useEffect(() => {\n    refs.current = { persistOptions, onSuccess }\n  })\n\n  React.useEffect(() => {\n    let isStale = false\n    setIsRestoring(true)\n    const [unsubscribe, promise] = persistQueryClient({\n      ...refs.current.persistOptions,\n      queryClient: client,\n    })\n\n    promise.then(() => {\n      if (!isStale) {\n        refs.current.onSuccess?.()\n        setIsRestoring(false)\n      }\n    })\n\n    return () => {\n      isStale = true\n      unsubscribe()\n    }\n  }, [client])\n\n  return (\n    <QueryClientProvider client={client} {...props}>\n      <IsRestoringProvider value={isRestoring}>{children}</IsRestoringProvider>\n    </QueryClientProvider>\n  )\n}\n","import { PersistedClient } from './persist'\n\nexport type PersistRetryer = (props: {\n  persistedClient: PersistedClient\n  error: Error\n  errorCount: number\n}) => PersistedClient | undefined\n\nexport const removeOldestQuery: PersistRetryer = ({ persistedClient }) => {\n  const mutations = [...persistedClient.clientState.mutations]\n  const queries = [...persistedClient.clientState.queries]\n  const client: PersistedClient = {\n    ...persistedClient,\n    clientState: { mutations, queries },\n  }\n\n  // sort queries by dataUpdatedAt (oldest first)\n  const sortedQueries = [...queries].sort(\n    (a, b) => a.state.dataUpdatedAt - b.state.dataUpdatedAt\n  )\n\n  // clean oldest query\n  if (sortedQueries.length > 0) {\n    const oldestData = sortedQueries.shift()\n    client.clientState.queries = queries.filter(q => q !== oldestData)\n    return client\n  }\n\n  return undefined\n}\n"],"names":["defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","dehydrate","client","options","mutations","queries","dehydrateMutations","shouldDehydrateMutation","getMutationCache","getAll","forEach","push","mutationKey","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","getQueryCache","queryKey","queryHash","dehydrateQuery","async","persistQueryClientRestore","queryClient","persister","maxAge","buster","hydrateOptions","persistedClient","restoreClient","timestamp","expired","Date","now","busted","removeClient","dehydratedState","mutationCache","queryCache","dehydratedMutation","_options$defaultOptio","build","defaultOptions","dehydratedQuery","_options$defaultOptio2","get","dataUpdatedAt","setState","hydrate","clientState","err","persistQueryClientSave","dehydrateOptions","persistClient","persistQueryClientSubscribe","props","unsubscribeQueryCache","subscribe","unusbscribeMutationCache","persistQueryClient","hasUnsubscribed","persistQueryClientUnsubscribe","then","defaultContext","React","createContext","undefined","QueryClientSharingContext","QueryClientProvider","children","context","contextSharing","useEffect","mount","unmount","Context","window","ReactQueryClientContext","getQueryClientContext","createElement","Provider","value","IsRestoringProvider","persistOptions","onSuccess","isRestoring","setIsRestoring","useState","refs","useRef","current","isStale","unsubscribe","promise","_extends","sortedQueries","sort","a","b","length","oldestData","shift","filter","q"],"mappings":"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"}